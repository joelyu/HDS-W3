---
title: "Immune Cell Infiltration Across Breast Cancer Subtypes: A Marker Gene Analysis of the METABRIC Cohort"
author: "cyy36@cam.ac.uk"
date: today
bibliography: references.bib
csl: nature.csl
link-citations: true
execute:
  warning: false
  message: false
  echo: false
  cache: true
format:
  html:
    toc: true
    toc-location: left
    toc-depth: 2
    embed-resources: true
    theme:
      light: flatly
      dark: darkly
---

# Cover Page {.unnumbered .unlisted}

<center>
![](https://onlinecareeraccelerators.pace.cam.ac.uk/hubfs/CAM%20DS%20PACE/Professional%20and%20Continuing%20Education_V_reversed%20colour%201.svg)
</center>

### MSt Healthcare Data Science {.unnumbered .unlisted}

#### Authentication of practice

|   |   |
|---|---|
|I confirm that I have fully read and understood the assignment brief for this module.| **Y** |

#### Details

|   |   |
|---|---|
|Name: Chung Yan|Surname: Yu|
|Submission Date|  |
|Word Count: whole assignment including codes|  |
|Word Count: main body excluding abstract, references and supplementary materials|  |

#### Permission to share your assignment

I do give permission to share my assignment with future MSt participants.

#### University statement of originality

This assignment is the result of my own work and includes nothing which is the outcome of work done in collaboration except as declared in the Preface and specified in the text. It is not substantially the same as any that I have previously submitted for a degree or diploma or other qualification at the University of Cambridge or any other university or similar institution, or that is being concurrently submitted, except as declared in the Preface and specific in the text. I further state that no substantial part of my Portfolio has already been submitted, nor is being concurrently submitted for any such degree, diploma or other qualification at the University of Cambridge or any other university or similar institution except as declared in the Preface and specified in the text.

|   |   |
|---|---|
|I confirm the statement of originality as above| **Y** |


#### Questions for reflection

Self-assessment is an important aspect of feedback literacy, which is, in turn, key to the development of expertise. As you proceed through the MSt Healthcare data science programme, we hope that you will make use of the following prompts to assess your own work on assignments. Specific assignment briefs will likely indicate which of these to address for which assessments, but, in general, we expect you to respond to one or two for each assignment on your course.

For each of the questions, do not spend too long answering – keep it brief. For each question you answer, limit yourself to no more than three items. And please remember, this is optional and developmental: these cover sheets are designed to create space for self-assessment and feedback dialogue, rather than additional assignment workload.

1. Which aspects of this assignment are you most uncertain about and/or would most like to receive feedback on?


2. What elements are you left pondering after this assignment that you would like to discuss further?


3. How have you incorporated feedback from peers and tutors into this assignment?


4. How, and to what extent, have you been able to incorporate feedback on previous course work into this assignment?


5. Using the wording in the rubric, how would you describe the quality of the different aspects of your work?


### Declaration of the use of generative AI {.unnumbered .unlisted}

|   |   |
|---|---|
|Which permitted use of generative AI are you acknowledging?| Semantic search of literature and notes, outline creation, output formatting, informed feedback, code generation |
|Which generative AI tool did you use (name and version)?| Claude Code v2.1.1x (Opus 4.6), M365 CoPilot |
|What did you use the tool for?| Searching for relevant journal publications (via PubMed MCP), collating notes in my Obsidian vault, `.bib` file curation, code debugging+generation |
|How have you used or changed the generative AI's output| My collated notes always stay in point form so that I write out the paragraphs in my own words. Feedback provided by the GenAI models are weighed and assessed before being acted on. |



# Abstract

The ability for immune cells to infiltrate the tumour microenvironment (TME).

# Introduction

The ability for immune cells to infiltrate the tumour microenvironment (TME).

# Methods

This study makes use of the METABRIC dataset[@curtis2012genomic] available on CBioPortal[@cerami2012cbioportal; @gao2013integrative; @debruijn2023analysis], including clinical, gene expression and mutation datasets of 2,509 patients.

```{r setup, output=FALSE}
#| label: setup
#| code-summary: "Setup: Installing and verifying packages, setting up filepaths"

# --- Package installation and loading ---
# Most of the packages are handled via conda/mamba
# This is to verify the packages and install them if missing
# Certain packages are hard to retrieve when on arm64 macs, these are loaded below
# File and folder paths for downstream processing are also defined here
options(repos = c(CRAN = "https://cloud.r-project.org"))

if (!require(tidyverse, quietly = TRUE))    install.packages("tidyverse")
if (!require(survival, quietly = TRUE))     install.packages("survival")
if (!require(survminer, quietly = TRUE))    install.packages("survminer")
if (!require(gtsummary, quietly = TRUE))    install.packages("gtsummary")
if (!require(UpSetR, quietly = TRUE))       install.packages("UpSetR")
if (!require(forestplot, quietly = TRUE))   install.packages("forestplot")
if (!require(pheatmap, quietly = TRUE))     install.packages("pheatmap")
if (!require(ggpubr, quietly = TRUE))       install.packages("ggpubr")
if (!require(patchwork, quietly = TRUE))    install.packages("patchwork")
if (!require(RColorBrewer, quietly = TRUE))  install.packages("RColorBrewer")
if (!require(multcompView, quietly = TRUE)) install.packages("multcompView")
if (!require(ggrepel, quietly = TRUE))      install.packages("ggrepel")
if (!require(cluster, quietly = TRUE))      install.packages("cluster")

if (!require(BiocManager, quietly = TRUE))  install.packages("BiocManager")
if (!require(ComplexHeatmap, quietly = TRUE)) BiocManager::install("ComplexHeatmap")
if (!require(cBioPortalData, quietly = TRUE)) BiocManager::install("cBioPortalData")

library(tidyverse)
library(survival)
library(survminer)
library(gtsummary)
library(UpSetR)
library(forestplot)
library(pheatmap)
library(ComplexHeatmap)
ht_opt$message <- FALSE
library(ggpubr)
library(patchwork)
library(RColorBrewer)

# --- P-value formatter: 3 decimals, or <0.001 ---
fmt_p <- function(p) ifelse(p < 0.001, "<0.001", sprintf("%.3f", p))

# --- Data paths (relative to repo root) ---
proc_dir  <- "data/processed"
clin_file <- file.path(proc_dir, "clinical.csv")
mut_file  <- file.path(proc_dir, "mutations.maf")
expr_file <- file.path(proc_dir, "expression_immune_markers.csv")
```
```{r}
#| label: import-scoring-exploration
#| output: false
#| echo: true
#| code-fold: true
#| code-summary: "Data loading, immune cell scoring, and exploration"
# To pull fresh data from cBioPortal instead of using the included processed files,
# delete the data/processed/ folder and re-render this document.
source("scripts/00-data-cleaning.R")
source("scripts/01-immune-cell-scoring.R")
source("scripts/02-task1-exploration.R")
```

<!-- TODO: Methods prose -->

```{r methods-coverage}
#| label: methods-coverage
#| code-summary: "Show gene coverage for immune cell scoring"
coverage_df %>%
  group_by(Cell_type) %>%
  summarise(
    Markers = n(),
    Found = sum(In_METABRIC),
    Missing = paste(Gene[!In_METABRIC], collapse = ", "),
    .groups = "drop"
  ) %>%
  mutate(Missing = ifelse(Missing == "", "\u2014", Missing)) %>%
  dplyr::rename(`Cell type` = Cell_type) %>%
  knitr::kable(format = "html") %>%
  kableExtra::column_spec(1, width = "16em") %>%
  kableExtra::column_spec(2, width = "8em") %>%
  kableExtra::column_spec(3, width = "8em")
```

::: {.callout-note appearance="minimal"}
### Table S1 - Immune marker gene coverage
58 of 60 Danaher et. al[@danaher2017gene] marker genes spanning 14 cell types were available on the Illumina HT-12 v3 microarray. TPSB2 (Mast cells) and XCL2 (NK cells) are absent from the platform; scoring proceeds with remaining markers. A 15th cell type (CD4 T cells) is derived as the T-cell score minus the CD8 T-cell score.
:::


# Results

## Cohort Summary and Mutation Landscape

::: {#panel-cohort-table}
```{r task1-table1}
#| label: task1-table1
tbl1
```

::: {.callout-note appearance="minimal"}
### Table 1 - Cohort characteristics by PAM50 subtype
Baseline characteristics of 1,756 METABRIC patients with expression data, stratified by PAM50 intrinsic subtype. 218 claudin-low and 6 NC patients excluded. Continuous variables summarised as median (Q1, Q3); categorical as n (%). P-values from Kruskal-Wallis (continuous) or Pearson's Chi-squared (categorical) tests.
:::
:::

::: {#panel-upset}
```{r task1-upset, fig.width=10, fig.height=6}
#| label: task1-upset
#| code-summary: "Show patient intersection across datasets"
upset(
  membership[, -1],
  sets = c("Clinical", "Expression", "Mutations", "PAM50"),
  order.by = "freq",
  mainbar.y.label = "Patients",
  sets.x.label = "Patients per modality",
  main.bar.color = "#8DA0CB",
  sets.bar.color = "#8DA0CB",
  text.scale = c(1.5, 1.3, 1.2, 1.2, 1.5, 1.2),
  mb.ratio = c(0.6, 0.4)
)
```

::: {.callout-note appearance="minimal"}
### Figure 1 - Data availability across modalities
Vertical bars show patient counts for each combination of available data modalities; horizontal bars show totals per modality. Of 2,509 METABRIC patients, 1,859 have clinical, mutation, and expression (and hence PAM50) data. 529 patients lack expression data and consequently lack PAM50 classification.
:::
:::

```{r task1-missing-age}
#| label: task1-missing-age
#| code-summary: "Compare age between patients with and without expression data"
expr_ages <- clinical$age_at_diagnosis[clinical$has_expression]
no_expr_ages <- clinical$age_at_diagnosis[!clinical$has_expression]
n_no_expr <- sum(!clinical$has_expression)
n_expr <- sum(clinical$has_expression)
age_wilcox <- wilcox.test(no_expr_ages, expr_ages)
```

The `r n_no_expr` patients without expression data were significantly younger than the `r n_expr` with expression data (median age `r round(median(no_expr_ages, na.rm = TRUE), 1)` vs `r round(median(expr_ages, na.rm = TRUE), 1)` years; Wilcoxon rank-sum p `r if(age_wilcox$p.value < 0.001) "< 0.001" else paste("=", sprintf("%.3f", age_wilcox$p.value))`).

```{r task1-mutations-compute, output=FALSE}
#| label: task1-mutations-compute
source("scripts/04-mutation-exploration.R")
```

::: {#panel-dotplot}
```{r task1-dotplot, fig.width=9, fig.height=9}
#| label: task1-dotplot
if (length(sig_genes) > 0) {
  dot_data <- wilcox_results %>%
    filter(gene %in% sig_genes) %>%
    mutate(
      cell_type = gsub("_", " ", cell_type),
      neg_log_fdr = -log10(pmax(fdr, 1e-300)),
      significant = fdr < 0.05,
      sig_category = case_when(
        fdr < 0.05 & !is.na(adj_fdr) & adj_fdr < 0.05 ~ "Significant after PAM50 adjustment",
        fdr < 0.05 ~ "Significant only before PAM50 adjustment",
        TRUE ~ "NS"
      ),
      sig_category = factor(sig_category,
        levels = c("Significant after PAM50 adjustment", "Significant only before PAM50 adjustment", "NS"))
    )

  # Order genes by number of significant associations (most at top)
  gene_summary <- dot_data %>%
    group_by(gene) %>%
    summarise(n_sig = sum(significant), n_mut = n_mut[1], .groups = "drop") %>%
    arrange(desc(n_sig))
  dot_data$gene <- factor(dot_data$gene, levels = rev(gene_summary$gene))

  # Gene labels for y-axis: include patient count and sig count
  gene_labels <- setNames(
    paste0(gene_summary$gene, "\n(n=", gene_summary$n_mut, ", ",
           gene_summary$n_sig, " sig)"),
    gene_summary$gene
  )

  max_abs_effect <- max(abs(dot_data$effect), na.rm = TRUE)

  # Count significant genes per cell type for x-axis labels
  sig_per_ct <- dot_data %>%
    group_by(cell_type) %>%
    summarise(n_sig = sum(significant), .groups = "drop")
  ct_labels <- setNames(
    paste0(sig_per_ct$cell_type, "\n(", sig_per_ct$n_sig, ")"),
    sig_per_ct$cell_type
  )

  ggplot(dot_data, aes(x = cell_type, y = gene)) +
    geom_point(aes(size = neg_log_fdr, fill = effect, colour = sig_category),
               shape = 21, stroke = 0.9) +
    scale_size_continuous(range = c(3, 10),
                          name = expression(-log[10](FDR))) +
    scale_fill_gradient2(low = "#3288BD", mid = "#FFFFBF", high = "#D53E4F",
                         midpoint = 0,
                         limits = c(-max_abs_effect, max_abs_effect),
                         name = "Effect\n(\u0394 median)") +
    scale_colour_manual(
      values = c("Significant after PAM50 adjustment" = "black",
                 "Significant only before PAM50 adjustment" = "#E78AC3",
                 "NS" = "grey75"),
      name = "Subtype confounding") +
    scale_x_discrete(labels = ct_labels) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
      axis.text.y = element_text(angle = 30, hjust = 1, size = 9),
      panel.grid.major = element_line(colour = "grey92"),
      legend.position = "bottom",
      legend.box = "horizontal",
      legend.direction = "horizontal",
      legend.box.margin = margin(t = 5),
      legend.spacing.x = unit(0.5, "cm")
    ) +
    guides(
      fill = guide_colorbar(title.position = "top", barwidth = 6, barheight = 0.5, order = 1),
      size = guide_legend(title.position = "top", nrow = 1, order = 2),
      colour = guide_legend(title.position = "top", nrow = 2, order = 3, override.aes = list(size = 5))
    ) +
    scale_y_discrete(labels = gene_labels) +
    labs(x = NULL, y = NULL)
}
```

::: {.callout-note appearance="minimal"}
### Figure 2 - Mutation-immune cell score associations
Dot plot of median immune score differences (mutated minus wild-type) for genes with at least one significant association (BH FDR < 0.05) across 14 cell types. Only genes mutated in ≥10 patients were tested. Dot size encodes statistical significance (−log₁₀ FDR); fill colour encodes effect direction and magnitude (red = higher in mutated; blue = lower). Border colour indicates PAM50 adjustment status: black = significant after adjusting for intrinsic subtype (independent effect), lilac = significant unadjusted but lost after PAM50 adjustment (confounded by subtype), grey = not significant. Genes ordered by number of significant associations; y-axis labels show patient count and significant cell types per gene; x-axis labels show significant genes per cell type.
:::
:::

::: {#panel-volcano}
```{r task1-tp53-volcano, fig.width=8, fig.height=6}
#| label: task1-tp53-volcano
# TP53 volcano: PAM50-adjusted effect sizes and FDR
tp53_adj <- wilcox_results %>%
  filter(gene == "TP53" & !is.na(adj_effect)) %>%
  mutate(
    cell_type = gsub("_", " ", cell_type),
    neg_log_fdr = -log10(pmax(adj_fdr, 1e-300)),
    significant = adj_fdr < 0.05
  )

n_tp53_sig <- sum(tp53_adj$significant)
n_tp53_total <- nrow(tp53_adj)

ggplot(tp53_adj, aes(x = adj_effect, y = neg_log_fdr)) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed",
             colour = "grey50", linewidth = 0.5) +
  geom_vline(xintercept = 0, linetype = "dotted", colour = "grey70") +
  geom_point(aes(colour = significant), size = 4) +
  ggrepel::geom_text_repel(
    aes(label = cell_type), size = 3.2,
    max.overlaps = 20, segment.colour = "grey70"
  ) +
  scale_colour_manual(
    values = c("TRUE" = "#E41A1C", "FALSE" = "grey60"),
    labels = c("TRUE" = "FDR < 0.05", "FALSE" = "NS"), name = NULL
  ) +
  theme_minimal() +
  theme(legend.position = "bottom") +
  labs(
    x = "PAM50-adjusted effect (TP53 mutated vs wild-type)",
    y = expression(-log[10](adjusted~FDR)),
    title = sprintf("TP53 mutation: %d/%d cell types significant after PAM50 adjustment",
                    n_tp53_sig, n_tp53_total)
  )
```

::: {.callout-note appearance="minimal"}
### Figure 3 - TP53 mutation and immune infiltration after PAM50 adjustment
Volcano plot showing the association between TP53 mutation and each immune cell type score after adjusting for PAM50 intrinsic subtype via linear regression. X-axis shows the PAM50-adjusted effect size (coefficient for TP53 mutation status); y-axis shows statistical significance. Dashed line marks adjusted FDR = 0.05. TP53 mutation associates with broadly elevated immune infiltration independent of subtype, consistent with genomic instability driving neoantigen-mediated immune recruitment.
:::
:::


## Immune Infiltration Across PAM50 Subtypes

```{r q1-compute, output=FALSE}
#| label: q1-compute
source("scripts/03-q1-pam50-immune.R")
```

::: {#panel-heatmap}
```{r q1-heatmap, fig.width=9, fig.height=10}
#| label: q1-heatmap
ha <- HeatmapAnnotation(
  PAM50 = pam50_vals,
  col = list(PAM50 = pam50_colours),
  show_legend = TRUE,
  annotation_legend_param = list(PAM50 = list(direction = "horizontal", nrow = 1))
)
draw(Heatmap(
  heatmap_z, name = "Z-score",
  col = circlize::colorRamp2(c(-2, 0, 2), c("#3288BD", "#FFFFBF", "#D53E4F")),
  top_annotation = ha,
  cluster_rows = TRUE, cluster_columns = TRUE,
  show_column_names = FALSE,
  row_names_gp = gpar(fontsize = 10),
  column_split = pam50_vals,
  column_title_gp = gpar(fontsize = 10),
  use_raster = TRUE,
  heatmap_legend_param = list(direction = "horizontal")
), heatmap_legend_side = "bottom", annotation_legend_side = "bottom",
   merge_legend = TRUE)
```

::: {.callout-note appearance="minimal"}
### Figure 4 - Immune cell score heatmap across PAM50 subtypes
Z-scored immune cell type scores (rows) for 1,756 patients (columns), split by PAM50 subtype. Rows and columns are hierarchically clustered within each subtype. Blue indicates below-cohort-mean infiltration; red indicates above-cohort-mean infiltration.
:::
:::

::: {#panel-violin}
```{r q1-violin, fig.width=9, fig.height=18}
#| label: q1-violin

# Filter to KW-significant cell types only
sig_cell_types <- kw_results %>% filter(kw_fdr < 0.05) %>% pull(cell_type)
scores_violin <- scores_long %>% filter(cell_type %in% sig_cell_types)

# Order panels: CD45 and Cytotoxic first (umbrella markers), then alphabetical
priority_types <- c("CD45", "Cytotoxic cells")
other_types <- sort(setdiff(sig_cell_types, priority_types))
ct_order <- c(intersect(priority_types, sig_cell_types), other_types)
scores_violin$cell_type <- factor(scores_violin$cell_type, levels = ct_order)

# CLD letter positions (above global max per facet)
score_ranges <- scores_violin %>%
  group_by(cell_type) %>%
  summarise(y_min = min(score, na.rm = TRUE),
            y_max = max(score, na.rm = TRUE), .groups = "drop")

cld_plot <- cld_df %>%
  filter(cell_type %in% sig_cell_types) %>%
  left_join(score_ranges, by = "cell_type") %>%
  mutate(label_y = y_max + 0.05 * (y_max - y_min),
         cell_type = factor(cell_type, levels = ct_order))

ggplot(scores_violin, aes(x = pam50_subtype, y = score, fill = pam50_subtype)) +
  geom_violin(alpha = 0.7, scale = "width") +
  geom_boxplot(width = 0.15, outlier.size = 0.5, fill = "white", alpha = 0.8) +
  geom_text(
    data = cld_plot,
    aes(x = pam50_subtype, y = label_y, label = cld_letter),
    inherit.aes = FALSE,
    size = 3.5, fontface = "bold"
  ) +
  facet_wrap(~ cell_type, scales = "free_y", ncol = 2) +
  scale_fill_manual(values = pam50_colours) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    legend.position = "none",
    strip.text = element_text(face = "bold")
  ) +
  labs(x = NULL, y = "Immune score (mean log2 expression)")
```

::: {.callout-note appearance="minimal"}
### Figure 5 - Immune cell scores by PAM50 subtype
Violin plots with embedded box plots for immune cell type scores across five PAM50 subtypes, restricted to cell types reaching Kruskal-Wallis FDR < 0.05. Compact letter display (CLD) annotations indicate pairwise statistical groupings from Wilcoxon rank-sum tests with Benjamini-Hochberg correction; subtypes sharing a letter do not differ significantly (p > 0.05). Each panel uses an independent y-axis.
:::
:::


## Immune Scores and Overall Survival

```{r q2-compute, output=FALSE}
#| label: q2-compute
source("scripts/05-q3-survival.R")
```

::: {#panel-q2-forest}
```{r q2-forest, fig.width=10, fig.height=6}
#| label: q2-forest
cox_ordered <- cox_results %>% arrange(hr)
ggplot(cox_ordered, aes(x = hr, y = reorder(gsub("_", " ", cell_type), hr))) +
  geom_point(aes(colour = fdr < 0.05), size = 3) +
  geom_errorbarh(aes(xmin = hr_lower, xmax = hr_upper), height = 0.2) +
  geom_vline(xintercept = 1, linetype = "dashed", colour = "grey50") +
  scale_colour_manual(
    values = c("TRUE" = "#E41A1C", "FALSE" = "grey60"),
    labels = c("TRUE" = "FDR < 0.05", "FALSE" = "NS"), name = NULL
  ) +
  theme_minimal() +
  labs(x = "Hazard Ratio (per SD, 95% CI)", y = NULL) +
  theme(axis.text.y = element_text(size = 10), legend.position = "bottom")
```

```{r q2-cox-table}
#| label: q2-cox-table
cox_results %>%
  arrange(fdr) %>%
  mutate(
    cell_type = gsub("_", " ", cell_type),
    across(c(hr, hr_lower, hr_upper), ~ round(.x, 3)),
    across(c(p_value, fdr), fmt_p)
  ) %>%
  select(-n, -events) %>%
  knitr::kable(col.names = c("Cell type", "HR", "Lower 95% CI", "Upper 95% CI", "p-value", "FDR"))
```

::: {.callout-note appearance="minimal"}
### Figure 6 / Table 2 - Univariate Cox regression: immune scores and overall survival
Forest plot (above) and table of hazard ratios (per standard deviation increase) from univariate Cox proportional hazards models for each immune cell type score. Error bars show 95% confidence intervals. Red points indicate BH-adjusted FDR < 0.05; dashed line marks HR = 1 (no effect). Note: some cell types have 95% CIs excluding 1.0 (nominally significant) but are coloured grey because they do not survive FDR correction across 14 tests. N = 1,756 patients; 1,044 events (deaths).
:::
:::

::: {#panel-q2-km}
```{r q2-km-curves, fig.width=12, fig.height=8}
#| label: q2-km-curves
km_cell_types <- if (nrow(sig_cells) > 0) sig_cells$cell_type else {
  cox_results %>% arrange(p_value) %>% head(2) %>% pull(cell_type)
}
km_plots <- lapply(km_cell_types, function(ct) {
  plot_data <- surv_data
  plot_data$group <- factor(
    ifelse(plot_data[[ct]] >= median(plot_data[[ct]], na.rm = TRUE), "High", "Low"),
    levels = c("Low", "High")
  )
  fit <- survfit(Surv(os_months, os_event) ~ group, data = plot_data)
  ggsurvplot(
    fit, data = plot_data,
    pval = TRUE, pval.method = TRUE,
    risk.table = TRUE, risk.table.height = 0.25,
    palette = c("#377EB8", "#E41A1C"),
    xlab = "Time (months)", ylab = "Overall survival",
    legend.labs = c("Low", "High"),
    title = gsub("_", " ", ct),
    ggtheme = theme_minimal()
  )
})
arrange_ggsurvplots(km_plots, ncol = 2)
```

::: {.callout-note appearance="minimal"}
### Figure 7 - Kaplan-Meier survival curves for Mast cells and Macrophages
Kaplan-Meier curves for the two immune cell types reaching FDR < 0.05 in univariate Cox regression: Mast cells (protective, HR = 0.885) and Macrophages (adverse, HR = 1.091). Patients split at the median score into High and Low groups. P-values from log-rank test.
:::
:::


## Immune Score Stratification Within PAM50 Subtypes

```{r q3-within-compute, output=FALSE}
#| label: q3-within-compute
source("scripts/06-q3-within-subtype.R")
```

Q2 identified `r best_ct_label` as the most prognostic immune cell type (lowest FDR). We next tested whether this score refines prognosis *within* individual PAM50 subtypes using per-subtype univariate Cox models (continuous `r best_ct_label` score, HR per SD increase).

::: {#panel-q3-forest}
```{r q3-within-forest, fig.width=8, fig.height=5}
#| label: q3-within-forest
# Build forest plot data: per-subtype rows + overall adjusted row
forest_df <- within_cox %>%
  select(subtype, hr, hr_lower, hr_upper, fdr) %>%
  mutate(label = subtype, row_type = "subtype")

overall_row <- data.frame(
  subtype = "Overall (PAM50-adjusted)",
  hr = adjusted_hr, hr_lower = adjusted_hr_lower, hr_upper = adjusted_hr_upper,
  fdr = adjusted_p,  # use raw p for colouring (no FDR needed, single test)
  label = "Overall (PAM50-adjusted)", row_type = "overall"
)

forest_df <- bind_rows(forest_df, overall_row) %>%
  mutate(label = factor(label,
    levels = c("Overall (PAM50-adjusted)",
               within_cox$subtype[order(within_cox$hr)])))

ggplot(forest_df, aes(x = hr, y = label)) +
  geom_hline(yintercept = "Overall (PAM50-adjusted)",
             linetype = "solid", colour = "grey85", linewidth = 6) +
  geom_point(aes(colour = fdr < 0.05,
                 shape = row_type), size = 3) +
  geom_errorbarh(aes(xmin = hr_lower, xmax = hr_upper), height = 0.2) +
  geom_vline(xintercept = 1, linetype = "dashed", colour = "grey50") +
  scale_colour_manual(
    values = c("TRUE" = "#E41A1C", "FALSE" = "grey60"),
    labels = c("TRUE" = "p < 0.05", "FALSE" = "NS"), name = NULL
  ) +
  scale_shape_manual(values = c("subtype" = 16, "overall" = 18), guide = "none") +
  theme_minimal() +
  labs(x = "Hazard Ratio (per SD, 95% CI)", y = NULL) +
  theme(axis.text.y = element_text(size = 10), legend.position = "bottom")
```

```{r q3-within-table}
#| label: q3-within-table
within_summary %>%
  mutate(
    across(c(hr, hr_lower, hr_upper), ~ round(.x, 3)),
    across(c(p_value, fdr), fmt_p)
  ) %>%
  select(-events) %>%
  knitr::kable(col.names = c("PAM50 Subtype", "N", "HR", "Lower 95% CI", "Upper 95% CI", "p-value", "FDR"), row.names = FALSE)
```

::: {.callout-note appearance="minimal"}
### Figure 8 / Table 3 - Per-subtype and PAM50-adjusted Cox regression: `r best_ct_label` score and overall survival
Forest plot (above) and table of hazard ratios (per standard deviation increase in `r best_ct_label` score). Upper rows in forest plot: univariate Cox models fitted within each PAM50 subtype (BH-adjusted FDR across 5 tests). Bottom row: PAM50-adjusted multivariable Cox model (diamond). Dashed line marks HR = 1 (no effect).
:::
:::

An interaction model (`r best_ct_label` score × PAM50 subtype) confirmed that the prognostic effect did not significantly differ across subtypes (likelihood ratio test p = `r fmt_p(interaction_p)`), suggesting a consistent but variably powered signal. After adjusting for PAM50 subtype, `r best_ct_label` remained independently prognostic (HR = `r round(adjusted_hr, 3)` [`r round(adjusted_hr_lower, 3)`–`r round(adjusted_hr_upper, 3)`], p = `r fmt_p(adjusted_p)`).


## Aggregating Immune Scores via Clustering

```{r ext-compute, output=FALSE}
#| label: ext-compute
source("scripts/07-extension.R")
```

::: {#panel-ext-heatmap}
```{r ext-heatmap, fig.width=9, fig.height=5}
#| label: ext-heatmap
# Cluster centroid heatmap
centroid_long <- as.data.frame(cluster_centroids) %>%
  rownames_to_column("cluster") %>%
  pivot_longer(-cluster, names_to = "cell_type", values_to = "z_score") %>%
  mutate(cell_type = gsub("_", " ", cell_type))

ggplot(centroid_long, aes(x = cell_type, y = cluster, fill = z_score)) +
  geom_tile(colour = "white", linewidth = 0.5) +
  geom_text(aes(label = round(z_score, 1)), size = 3) +
  scale_fill_gradient2(low = "#3288BD", mid = "#FFFFBF", high = "#D53E4F",
                       midpoint = 0, name = "Mean z-score") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = NULL, y = NULL)
```

::: {.callout-note appearance="minimal"}
### Figure 9 - Immune cluster centroids
Mean z-scored immune cell type profiles for `r optimal_k` patient clusters identified by k-means clustering on all 14 Danaher cell type scores. Clusters labelled by overall immune level (Cluster 1 = highest mean immune score). Red indicates above-average infiltration; blue indicates below-average.
:::
:::

::: {#panel-ext-km}
```{r ext-km, fig.width=10, fig.height=6}
#| label: ext-km
p_ext <- ggsurvplot(
  cluster_fit, data = surv_data,
  pval = TRUE, pval.method = TRUE,
  risk.table = TRUE, risk.table.height = 0.25,
  legend.labs = levels(surv_data$immune_cluster),
  xlab = "Time (months)", ylab = "Overall survival",
  ggtheme = theme_minimal()
)
print(p_ext)
```

::: {.callout-note appearance="minimal"}
### Figure 10 - Overall survival by immune cluster
Kaplan-Meier curves stratified by immune cluster membership. P-value from log-rank test across `r optimal_k` groups.
:::
:::

::: {#panel-ext-comparison}
```{r ext-comparison}
#| label: ext-comparison
comparison_df %>%
  mutate(
    concordance = round(concordance, 3),
    AIC = round(AIC, 1),
    logrank_p = ifelse(is.na(logrank_p), "\u2014", fmt_p(logrank_p))
  ) %>%
  knitr::kable(col.names = c("Model", "df", "Concordance", "AIC", "Log-rank p"))
```

::: {.callout-note appearance="minimal"}
### Table 4 - Prognostic comparison: single cell type vs immune cluster
Comparison of Cox proportional hazards models using the single most prognostic cell type (`r best_ct_label`, continuous per-SD) versus immune cluster membership (k=`r optimal_k`, factor). Concordance (C-index) measures discriminative ability; AIC penalises model complexity. Lower AIC indicates better fit.
:::
:::


## Extension Exploration (temporary — pick one) {.unnumbered}

```{r ext-explore, output=FALSE}
#| label: ext-explore
source("scripts/08-extension-explore.R")
```

**B: Treatment × mast cell interaction**

- Chemo × mast cell interaction LRT p = `r fmt_p(chemo_int_p)` (n=`r nrow(chemo_data)`)
- Hormone × mast cell interaction LRT p = `r fmt_p(hormone_int_p)` (n=`r nrow(hormone_data)`)

```{r ext-b-table}
#| label: ext-b-table
bind_rows(chemo_strat, hormone_strat) %>%
  mutate(across(c(hr, hr_lower, hr_upper), ~round(.x, 3)),
         p_value = fmt_p(p_value)) %>%
  knitr::kable(col.names = c("Group", "N", "Events", "HR", "Lower", "Upper", "p"))
```

**C: TP53 × mast cell interaction**

`r if (!is.na(tp53_int_p)) sprintf("TP53 × mast cell interaction LRT p = %s (n=%d)", fmt_p(tp53_int_p), nrow(ext_data_c)) else "TP53 not available"`

```{r ext-c-table}
#| label: ext-c-table
if (!is.null(tp53_strat)) {
  tp53_strat %>%
    mutate(across(c(hr, hr_lower, hr_upper), ~round(.x, 3)),
           p_value = fmt_p(p_value)) %>%
    knitr::kable(col.names = c("Group", "N", "Events", "HR", "Lower", "Upper", "p"))
}
```

**E: Relapse-free survival replication**

- RFS univariate: HR = `r round(rfs_hr, 3)` [`r round(rfs_hr_lower, 3)`–`r round(rfs_hr_upper, 3)`], p = `r fmt_p(rfs_p)` (n=`r nrow(rfs_data)`, `r s_rfs_uni$nevent` events)
- RFS PAM50-adjusted: HR = `r round(rfs_adj_hr, 3)` [`r round(rfs_adj_hr_lower, 3)`–`r round(rfs_adj_hr_upper, 3)`], p = `r fmt_p(rfs_adj_p)`
- RFS screening: `r n_rfs_sig`/14 cell types FDR < 0.05

```{r ext-e-table}
#| label: ext-e-table
rfs_cox_results %>%
  arrange(fdr) %>%
  mutate(cell_type = gsub("_", " ", cell_type),
         across(c(hr, hr_lower, hr_upper), ~round(.x, 3)),
         across(c(p_value, fdr), fmt_p)) %>%
  select(-n, -events) %>%
  knitr::kable(col.names = c("Cell type", "HR", "Lower", "Upper", "p-value", "FDR"))
```

# Discussion

<!-- TODO -->

# Conclusion

<!-- TODO -->

# References

::: {#refs}
:::

# Addendum

Even if my day job is somewhat cancer adjacent, diving deep into this METABRIC dataset made me feel like a novice when it came to cancer / breast cancer. But it has been fun seeing what we learn in class come together in more ways than one. The lead authors for the immune cell scoring paper are from the company NanoString Technologies, the same company that has the commercial PAM50 test kit that we learned in class. And in the same paper, they cite the false discovery rate (FDR) correction paper from Benjamini and Hochberg!